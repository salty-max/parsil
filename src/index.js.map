{
  "version": 3,
  "sources": ["src/input-types.ts", "src/util/unicode.ts", "src/parser/parser.ts", "src/parsers/sequence-of/sequence-of.ts", "src/parsers/between/between.ts", "src/parsers/bit/bit.ts", "src/parsers/bit/zero.ts", "src/parsers/bit/one.ts", "src/parsers/bit/uint.ts", "src/parsers/bit/int.ts", "src/parsers/fail/fail.ts", "src/parsers/succeed/succeed.ts", "src/parsers/bit/raw-string.ts", "src/parsers/char/char.ts", "src/parsers/char/any-char.ts", "src/parsers/char/any-char-except.ts", "src/parsers/everything-until/everything-until.ts", "src/parsers/char/every-char-until.ts", "src/parsers/choice/choice.ts", "src/parsers/coroutine/coroutine.ts", "src/parsers/digits/digit.ts", "src/parsers/regex/regex.ts", "src/parsers/digits/digits.ts", "src/parsers/end-of-input/end-of-input.ts", "src/parsers/exactly/exactly.ts", "src/parsers/letters/letter.ts", "src/parsers/letters/letters.ts", "src/parsers/look-ahead/look-ahead.ts", "src/parsers/many/many.ts", "src/parsers/many/many-one.ts", "src/parsers/peek/peek.ts", "src/parsers/possibly/possibly.ts", "src/parsers/recursive/recursive.ts", "src/parsers/sep-by/sep-by.ts", "src/parsers/sep-by/sep-by-one.ts", "src/parsers/start-of-input/start-of-input.ts", "src/parsers/str/str.ts", "src/parsers/whitespace/whitespace.ts", "src/parsers/whitespace/optional-whitespace.ts", "src/index.ts"],
  "sourcesContent": [
    "export type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array\n\nexport type InputType = string | ArrayBuffer | DataView | TypedArray\n\nexport const isTypedArray = (x: unknown) =>\n  x instanceof Uint8Array ||\n  x instanceof Uint8ClampedArray ||\n  x instanceof Int8Array ||\n  x instanceof Uint16Array ||\n  x instanceof Int16Array ||\n  x instanceof Uint32Array ||\n  x instanceof Int32Array ||\n  x instanceof Float32Array ||\n  x instanceof Float64Array\n\nexport enum InputTypes {\n  STRING = 'string',\n  ARRAY_BUFFER = 'arrayBuffer',\n  TYPED_ARRAY = 'typedArray',\n  DATA_VIEW = 'dataView',\n}\n",
    "const Encoder = globalThis.TextEncoder\nconst Decoder = globalThis.TextDecoder\n\nif (!Encoder || !Decoder) {\n  throw new Error('Parsil requires global TextEncoder and TextDecoder')\n}\n\nexport const encoder = new Encoder()\nexport const decoder = new Decoder()\n\nexport const getString = (\n  index: number,\n  length: number,\n  dataView: DataView\n) => {\n  const bytes = new Uint8Array(length)\n  for (let i = 0; i < length; i++) bytes[i] = dataView.getUint8(index + i)\n  return decoder.decode(bytes)\n}\n\nexport const getNextCharWidth = (index: number, dataView: DataView) => {\n  const byte = dataView.getUint8(index)\n  if ((byte & 0x80) === 0x00) return 1 // 0xxxxxxx\n  if ((byte & 0xe0) === 0xc0) return 2 // 110xxxxx\n  if ((byte & 0xf0) === 0xe0) return 3 // 1110xxxx\n  if ((byte & 0xf8) === 0xf0) return 4 // 11110xxx\n  return 1 // fallback\n}\n\nexport const getUtf8Char = (\n  index: number,\n  length: number,\n  dataView: DataView\n) => {\n  const bytes = new Uint8Array(length)\n  for (let i = 0; i < length; i++) bytes[i] = dataView.getUint8(index + i)\n  return decoder.decode(bytes)\n}\n\nexport const getCharacterLength = (str: string): number => {\n  let count = 0\n  for (const _ of str) count++\n  return count\n}\n",
    "import { InputType, InputTypes, isTypedArray } from '../input-types'\nimport { encoder } from '../util'\n\n/**\n * Defines the internal structure of the parser result\n * @template T The result type\n * @template E The error type\n */\nexport type InternalResultType<T, E> = {\n  isError: boolean\n  error: E\n  index: number\n  result: T\n}\n\n/**\n * ParserState represents the state of the parser.\n * @template T The type of the result\n * @template E The type of the error\n */\nexport type ParserState<T, E> = {\n  dataView: DataView\n  inputType: InputType\n} & InternalResultType<T, E>\n\n/**\n * StateTransformerFn is a function type used to transform one parser state into another.\n * @template T The type of the result\n * @template E The type of the error, defaults to 'any'\n */\nexport type StateTransformerFn<T, E = any> = (\n  state: ParserState<any, any>\n) => ParserState<T, E>\n\n/**\n * ResultType represents a type that is either an error or a success.\n * @template T The result type\n * @template E The error type\n */\nexport type ResultType<T, E> = Err<E> | Ok<T>\n\n/**\n * Represents an error in parsing.\n * @template E The error type\n */\nexport type Err<E> = {\n  isError: true\n  error: E\n  index: number\n}\n\n/**\n * Represents a successful parse result.\n * @template T The result type\n */\nexport type Ok<T> = {\n  isError: false\n  result: T\n  index: number\n}\n\nexport function isOk<T, E>(result: ResultType<T, E>): result is Ok<T> {\n  return !result.isError\n}\n\nexport function isError<T, E>(result: ResultType<T, E>): result is Err<E> {\n  return result.isError\n}\n\nconst createParserState = (\n  target: InputType\n): ParserState<null, string | null> => {\n  let dataView: DataView\n  let inputType\n\n  if (typeof target === 'string') {\n    const bytes = encoder.encode(target)\n    dataView = new DataView(bytes.buffer)\n    inputType = InputTypes.STRING\n  } else if (target instanceof ArrayBuffer) {\n    dataView = new DataView(target)\n    inputType = InputTypes.ARRAY_BUFFER\n  } else if (isTypedArray(target)) {\n    dataView = new DataView(target.buffer)\n    inputType = InputTypes.TYPED_ARRAY\n  } else if (target instanceof DataView) {\n    dataView = target\n    inputType = InputTypes.DATA_VIEW\n  } else {\n    throw new Error(\n      `Cannot process input. Must be a string, ArrayBuffer, TypedArray, or DataView. Got ${typeof target}`\n    )\n  }\n\n  return {\n    dataView,\n    inputType,\n    isError: false,\n    error: null,\n    result: null,\n    index: 0,\n  }\n}\n\n/**\n * Represents a parser which transforms input data to the required structure\n * @template T The result type\n * @template E The error type\n */\nexport class Parser<T, E = string> {\n  p: StateTransformerFn<T, E> // The state transformer function for this parser.\n\n  /**\n   * Constructs a parser instance using a parser state transformer function.\n   * @param parserStateTransformerFn The state transformer function for the parser.\n   */\n  constructor(p: StateTransformerFn<T, E>) {\n    this.p = p\n  }\n\n  /**\n   * `.run` starts the parsing process on an input, initializing the state, and applying the transformer function.\n   * @param target The input to be parsed.\n   * @returns The resulting parser state.\n   */\n  run(target: InputType): ResultType<T, E> {\n    const initialState = createParserState(target)\n    const resultState = this.p(initialState)\n\n    if (resultState.isError) {\n      return {\n        isError: true,\n        error: resultState.error,\n        index: resultState.index,\n      }\n    }\n\n    return {\n      isError: false,\n      result: resultState.result,\n      index: resultState.index,\n    }\n  }\n\n  /**\n   * `.fork` takes an input to parse, and two functions to handle the results of parsing:\n   * an error function that is called when parsing fails, and a success function that is called when parsing is successful.\n   * The fork method will run the parser on the input and, depending on the outcome, call the appropriate function.\n   *\n   * @param target The input to be parsed.\n   * @param errorFn A function that is called when parsing fails. It receives the error and the parser state as arguments.\n   * @param successFn A function that is called when parsing is successful. It receives the result and the parser state as arguments.\n   * @returns The result of calling either the `errorFn` or `successFn`, depending on whether parsing was successful or not.\n   */\n  fork<F>(\n    target: InputType,\n    errorFn: (error: E, parsingState: ParserState<T, E>) => F,\n    successFn: (result: T, parsingState: ParserState<T, E>) => F\n  ) {\n    const state = createParserState(target)\n    const newState = this.p(state)\n\n    if (newState.isError) {\n      return errorFn(newState.error, newState)\n    }\n\n    return successFn(newState.result, newState)\n  }\n\n  /**\n   * `.map` transforms the parser into a new parser that applies a function to the result of the original parser.\n   * @param fn A function that takes a result of type T and returns a result of type T2.\n   * @returns A new Parser instance that applies the function `fn` to the result.\n   */\n  map<T2>(fn: (oldRes: T) => T2): Parser<T2, E> {\n    return new Parser((state): ParserState<T2, E> => {\n      const newState = this.p(state)\n\n      if (newState.isError) return newState as unknown as ParserState<T2, E>\n\n      return updateResult(newState, fn(newState.result))\n    })\n  }\n\n  /**\n   * `.chain` transforms the parser into a new parser by applying a function to the result of the original parser.\n   * This function should return a new Parser that can be used to parse the next input. This is used\n   * for cases where the result of a parser is needed to decide what to parse next.\n   *\n   * @param fn A function that takes the result of type T from the original parser and returns a new Parser.\n   * @returns A new Parser instance that uses the function `fn` to decide what to parse next.\n   * This parser is used to parse the remainder of the input after the original parser has consumed its part.\n   */\n  chain<T2>(fn: (oldRes: T) => Parser<T2, E>): Parser<T2, E> {\n    return new Parser((state): ParserState<T2, E> => {\n      const nextState = this.p(state)\n\n      if (nextState.isError) return nextState as unknown as ParserState<T2, E>\n\n      return fn(nextState.result).p(nextState)\n    })\n  }\n\n  /**\n   * `.errorMap` transforms the parser into a new parser which applies a function `fn`\n   * to the error message and index of the original parser when it encounters an error.\n   *\n   * @param fn - This is a function that takes error message and index as inputs and returns a string.\n   * It is used to transform the error message in case the parsing fails.\n   *\n   * @returns - It returns a new Parser. The state transformer function of this new parser\n   * first applies the original parser's state transformer function and then,\n   * if there was an error, it updates the error message using the `fn` function.\n   */\n  errorMap<E2>(fn: (error: Err<E>) => E2): Parser<T, E2> {\n    return new Parser((state): ParserState<T, E2> => {\n      const nextState = this.p(state)\n      if (!nextState.isError) return nextState as unknown as ParserState<T, E2>\n\n      return updateError(\n        nextState,\n        fn({\n          isError: true,\n          error: nextState.error,\n          index: nextState.index,\n        })\n      )\n    })\n  }\n}\n\n/**\n * Updates the state of the parser with a new index and result.\n * @param oldState The previous state of the parser.\n * @param index The new index in the input.\n * @param result The new parsing result.\n * @returns A new parser state with updated index and result.\n */\nexport const updateState = <T, E, T2>(\n  state: ParserState<T, E>,\n  index: number,\n  result: T2\n): ParserState<T2, E> => ({\n  ...state,\n  index,\n  result,\n})\n\n/**\n * Updates the state of the parser with a new result.\n * @param state The previous state of the parser.\n * @param result The new parsing result.\n * @returns A new parser state with updated result.\n */\nexport const updateResult = <T, E, T2>(\n  state: ParserState<T, E>,\n  result: T2\n): ParserState<T2, E> => ({\n  ...state,\n  result,\n})\n\n/**\n * Updates the state of the parser with an error.\n * @param state The previous state of the parser.\n * @param errorMsg The error message.\n * @returns A new parser state with updated error information.\n */\nexport const updateError = <T, E, E2>(\n  state: ParserState<T, E>,\n  error: E2\n): ParserState<T, E2> => ({\n  ...state,\n  isError: true,\n  error,\n})\n",
    "import { Parser, updateResult } from '../../parser/parser'\n\n/**\n * `sequenceOf` is a parser combinator that accepts an array of parsers and applies them\n * in sequence to the input. If all parsers succeed, it returns an `Ok` result with an array\n * of their results and the next position in the input. If any parser fails, it fails immediately\n * and returns the error state of that parser.\n *\n * @example\n * const parser = sequenceOf([str(\"abc\"), str(\"123\")])\n * parser.run(\"abc123xyz\")  // returns { isError: false, result: [\"abc\", \"123\"], index: 6 }\n * parser.run(\"xyzabc123\")  // returns { isError: true, error: \"ParseError @ index 0 -> str: Tried to match 'abc', but got 'xyz...'\", index: 0 }\n *\n * @param parsers An array of parsers to apply in sequence.\n * @returns {Parser<any>} A parser that applies `parsers` in sequence.\n */\n\nexport function sequenceOf<T extends Parser<any, any>[]>(\n  parsers: T\n): Parser<{ [K in keyof T]: T[K] extends Parser<infer R> ? R : never }> {\n  return new Parser((state) => {\n    if (state.isError) return state;\n\n    const results: any[] = [];\n    let nextState = state;\n\n    for (const p of parsers) {\n      const out = p.p(nextState);\n\n      if (out.isError) return out;\n\n      nextState = out;\n      results.push(out.result);\n    }\n\n    return updateResult(nextState, results as any);\n  });\n}\n",
    "import { Parser } from '../../parser/parser'\nimport { sequenceOf } from '../sequence-of'\n\n/**\n * `between` is a parser combinator that matches the content between two other parsers, `leftParser` and `rightParser`.\n * It applies the `leftParser` and `rightParser` in sequence and then applies the `contentParser` to match the content in between.\n * It returns the result of the `contentParser` and discards the results of the `leftParser` and `rightParser`.\n *\n * @example\n * const parser = between(str(\"(\"), str(\")\"))(letters)\n * parser.run(\"(abc)\")  // returns \"abc\"\n * parser.run(\"(123)\")  // returns \"ParseError @ index 0 -> between: Expected '('\"\n * parser.run(\"abc\")  // returns \"ParseError @ index 0 -> between: Expected '('\"\n *\n * @template L The type of result that the `leftParser` produces.\n * @template T The type of result that the `contentParser` produces.\n * @template R The type of result that the `rightParser` produces.\n *\n * @param leftParser The parser that matches the left boundary.\n * @param rightParser The parser that matches the right boundary.\n * @param contentParser The parser that matches the content between the left and right boundaries.\n * @returns {Parser<T>} A parser that matches the content between the left and right boundaries.\n */\nexport const between =\n  <L, T, R>(leftParser: Parser<L>, rightParser: Parser<R>) =>\n  (contentParser: Parser<T>): Parser<T> =>\n    sequenceOf([leftParser, contentParser, rightParser]).map(([_, c]) => c as T)\n",
    "import { Parser, updateError, updateState } from '../../parser/parser'\n\n/**\n * `bit` reads the next bit from the input.\n * It returns the parsed bit as a number.\n *\n * @example\n * const parser = bit;\n * const data = new Uint8Array([42]).buffer\n * parser.run(new Dataview(data))  // returns the next bit from the bitset\n *\n * @returns {Parser<number>} A parser that reads the next bit from the input.\n */\nexport const bit: Parser<number> = new Parser((state) => {\n  if (state.isError) return state\n\n  const byteOffset = Math.floor(state.index / 8)\n\n  if (byteOffset >= state.dataView.byteLength) {\n    updateError(\n      state,\n      `ParseError @ index ${state.index} -> bit: Unexpected end of input`\n    )\n  }\n\n  const byte = state.dataView.getUint8(byteOffset)\n  const bitOffset = 7 - (state.index % 8)\n  const bit = (byte & (1 << bitOffset)) >> bitOffset\n\n  return updateState(state, state.index + 1, bit)\n})\n",
    "import { Parser, updateError, updateState } from '../../parser/parser'\nimport { bit } from './bit'\n\n/**\n * `zero` is similar to `bit` but expect the parsed bit to be 0.\n *\n * @example\n * const parser = zero;\n * const data = new Uint8Array([42]).buffer\n * parser.run(new Dataview(data))  // returns the next bit from the bitset if 0, else returns an error\n *\n * @returns {Parser<number>} A parser that reads the next bit (0) from the input.\n */\nexport const zero: Parser<number> = new Parser((state) => {\n  if (state.isError) return state\n\n  const bitAtIndex = bit.p(state)\n\n  if (bitAtIndex.result !== 0) {\n    return updateError(\n      state,\n      `ParseError @ index ${state.index} -> zero: Expected 0 but got 1`\n    )\n  }\n\n  return updateState(state, state.index + 1, bitAtIndex.result)\n})\n",
    "import { Parser, updateError, updateState } from '../../parser/parser'\nimport { bit } from './bit'\n\n/**\n * `one` is similar to `bit` but expect the parsed bit to be 1.\n *\n * @example\n * const parser = one;\n * const data = new Uint8Array([42]).buffer\n * parser.run(new Dataview(data))  // returns the next bit from the bitset if 1, else returns an error\n *\n * @returns {Parser<number>} A parser that reads the next bit (1) from the input.\n */\nexport const one: Parser<number> = new Parser((state) => {\n  if (state.isError) return state\n\n  const bitAtIndex = bit.p(state)\n\n  if (bitAtIndex.result !== 1) {\n    return updateError(\n      state,\n      `ParseError @ index ${state.index} -> one: Expected 1 but got 0`\n    )\n  }\n\n  return updateState(state, state.index + 1, bitAtIndex.result)\n})\n",
    "import { Parser } from '../../parser/parser'\nimport { sequenceOf } from '../sequence-of'\nimport { bit } from './bit'\n\n/**\n * `uint` reads the next `n` bits from the input and interprets them as an unsigned integer.\n *\n * @example\n * const parser = uint(8)\n * const input = new Uint8Array([42])\n * const result = parser.run(new DataView(input.buffer))\n *\n * @param n The number of bits to parse as an unsigned integer.\n * @returns {Parser<number>} A parser that reads the next `n` bits as an unsigned integer.\n */\nexport const uint = (n: number): Parser<number> => {\n  if (n < 1) {\n    throw new Error(`uint: n must be larger than 0, but got ${n}`)\n  }\n\n  if (n > 32) {\n    throw new Error(`uint: n must be less than 32, but got ${n}`)\n  }\n\n  return sequenceOf(Array.from({ length: n }, () => bit)).map(\n    (bits: number[]) => {\n      return bits.reduce((acc, bit, i) => {\n        return acc + Number(BigInt(bit) << BigInt(n - 1 - i))\n      }, 0)\n    }\n  )\n}\n",
    "import { Parser } from '../../parser/parser'\nimport { sequenceOf } from '../sequence-of'\nimport { bit } from './bit'\n\n/**\n * `int` reads the next `n` bits from the input and interprets them as an signed integer.\n *\n * @example\n * const parser = uint(4); // Parses 4 bits as an signed integer\n * parser.run(bitset)  // returns the parsed signed integer if successful, otherwise fails\n *\n * @param n The number of bits to parse as an signed integer.\n * @returns {Parser<number>} A parser that reads the next `n` bits as an signed integer.\n */\nexport const int = (n: number): Parser<number> => {\n  if (n < 1) {\n    throw new Error(`int: n must be larger than 0, but got ${n}`)\n  }\n\n  if (n > 32) {\n    throw new Error(`int: n must be less than 32, but got ${n}`)\n  }\n\n  return sequenceOf(Array.from({ length: n }, () => bit)).map(\n    (bits: number[]) => {\n      if (bits[0] === 0) {\n        return bits.reduce((acc, bit, i) => {\n          return acc + Number(BigInt(bit) << BigInt(n - 1 - i))\n        }, 0)\n      } else {\n        return -(\n          1 +\n          bits.reduce((acc, bit, i) => {\n            return acc + Number(BigInt(bit === 0 ? 1 : 0) << BigInt(n - 1 - i))\n          }, 0)\n        )\n      }\n    }\n  )\n}\n",
    "import { Parser, updateError } from '../../parser/parser'\n\n/**\n * `fail` is a parser that always fails with a given error message `error`. It does not consume any input.\n * This can be useful for explicitly handling error cases in your parsing logic.\n *\n * @example\n * const parser = fail(\"Always fails\")\n * parser.run(\"anything\")  // returns \"Always fails\"\n *\n * @param error The error message that this parser will always fail with.\n * @returns {Parser<any, E>} A parser that always fails with the error message `error`.\n */\nexport function fail<E>(error: E) {\n  return new Parser<any, E>((state) => {\n    if (state.isError) return state\n    return updateError(state, error)\n  })\n}\n",
    "import { Parser, updateResult } from '../../parser/parser'\n\n/**\n * `succeed` is a parser combinator that always succeeds and produces a constant value.\n * It ignores the input state and returns the specified value as the result.\n * @example\n * const parser = succeed(42);\n * parser.run(\"hello world\"); // returns { isError: false, result: 42, index: 0 }\n * @template T The type of the value produced by the parser.\n * @param value The value to be produced by the parser.\n * @returns {Parser<T>} A parser that always succeeds and produces the specified value.\n */\nexport function succeed<T>(value: T) {\n  return new Parser<T>((state) => {\n    return updateResult(state, value)\n  })\n}\n",
    "import { Parser } from '../../parser/parser'\nimport { fail } from '../fail'\nimport { sequenceOf } from '../sequence-of'\nimport { succeed } from '../succeed'\nimport { uint } from './uint'\n\n/**\n * `rawString` matches a string of characters exactly as provided.\n * Each character in the input string is converted to its corresponding ASCII code\n * and a parser is created for each ASCII code.\n * The resulting parsers are chained together using sequenceOf to ensure they are parsed in order.\n * The parser succeeds if all characters are matched in the input and fails otherwise.\n *\n * @example\n * const parser = rawString(\"hello\");\n * parser.run(\"hello world\"); // returns { isError: false, result: [104, 101, 108, 108, 111], index: 5 }\n *\n * @param s The string to match in the input.\n * @returns {Parser<number[], string>} A parser that matches the provided string as a sequence of ASCII codes.\n * @throws {Error} If the input string is empty.\n */\nexport const rawString = (s: string): Parser<number[], string> => {\n  if (s.length < 1) {\n    throw new Error(`rawString: input must be at least 1 character`)\n  }\n\n  const bytes = s\n    .split('')\n    .map((c) => c.charCodeAt(0))\n    .map((n) => {\n      return uint(8).chain((res) => {\n        if (res == n) {\n          return succeed(n)\n        } else {\n          return fail(\n            `ParseError -> rawString: Expected character ${String.fromCharCode(\n              n\n            )}, but got ${String.fromCharCode(res)}`\n          )\n        }\n      })\n    })\n\n  return sequenceOf(bytes)\n}\n",
    "import { Parser, ParserState, updateError, updateState } from '../../parser'\nimport { getCharacterLength, getNextCharWidth, getUtf8Char } from '../../util'\n\n/**\n * `char` is a parser that matches a given input character `c` at the start of its input.\n * If the input starts with `c`, it consumes the matched character and returns it.\n * If no match is found, it fails with an error message indicating where the mismatch occurred.\n * An error is also thrown if `char` is called without a string of length 1.\n *\n * @example\n * const parser = char(\"a\")\n * parser.run(\"abcd\")  // returns \"a\"\n * parser.run(\"1234\")  // returns \"ParseError @ index 0 -> char: Expected 'a', but got '1'\"\n * char(\"ab\")  // throws `char must be called with a single character, but got 'ab'`\n *\n * @param c The character to match against the input.\n * @throws {TypeError} If `c` is not a string of length 1.\n * @returns {Parser<string>} A parser that tries to match the input against `c`.\n */\nexport const char = (c: string): Parser<string> => {\n  if (!c || getCharacterLength(c) !== 1) {\n    throw new TypeError(\n      `char must be called with a single character, but got '${c}'`\n    )\n  }\n\n  return new Parser<string>((state): ParserState<string, string> => {\n    if (state.isError) return state\n\n    const { index, dataView } = state\n    if (index < dataView.byteLength) {\n      const charWidth = getNextCharWidth(index, dataView)\n      if (index + charWidth <= dataView.byteLength) {\n        const char = getUtf8Char(index, charWidth, dataView)\n        if (char === c) {\n          return updateState(state, index + charWidth, c)\n        }\n\n        return updateError(\n          state,\n          `ParseError @ index 0 -> char: Expected '${c}', but got '${char}'`\n        )\n      }\n    }\n\n    return updateError(\n      state,\n      `ParseError @ index 0 -> char: Expected '${c}', but got unexpected end of input`\n    )\n  })\n}\n",
    "import { Parser, ParserState, updateError, updateState } from '../../parser'\nimport { getNextCharWidth, getUtf8Char } from '../../util'\n\n/**\n * `anyChar` is a parser that matches any single character at the start of its input.\n * If the input starts with any character, it consumes that character and returns it.\n * If no character is found (i.e., if the input is empty or doesn't start with a character),\n * it fails with an error message indicating that an unexpected end of input has been reached.\n *\n * @example\n * anyChar.run(\"abcd\")  // returns \"a\"\n * anyChar.run(\"1234\")  // returns \"1\"\n * anyChar.run(\"\")  // returns \"ParseError @ index 0 -> anyChar: Expected a character, but got unexpected end of input\"\n *\n * @returns {Parser<string>} A parser that matches any character.\n */\nexport const anyChar: Parser<string> = new Parser(\n  (state): ParserState<string, string> => {\n    if (state.isError) return state\n\n    const { index, dataView } = state\n    if (index < dataView.byteLength) {\n      const charWidth = getNextCharWidth(index, dataView)\n      if (index + charWidth <= dataView.byteLength) {\n        const char = getUtf8Char(index, charWidth, dataView)\n        return updateState(state, index + charWidth, char)\n      }\n    }\n\n    return updateError(\n      state,\n      `ParseError @ index ${index} -> anyChar: Expected a character, but got unexpected end of input`\n    )\n  }\n)\n",
    "import { Parser, updateError, updateState } from '../../parser'\nimport { getNextCharWidth, getUtf8Char } from '../../util'\n\n/**\n * `anyCharExcept` matches any character except the ones matched by the given parser.\n * \n * @example\n * anyCharExcept (char ('.')).run('This is a sentence.')\n * -> {\n *       isError: false,\n *       result: 'T',\n *       index: 1,\n *    }\n\n * const manyExceptDot = many(anyCharExcept(char('.')))\n * manyExceptDot.run('This is a sentence.')\n * -> {\n *      isError: false,\n *      result: ['T', 'h', 'i', 's', ' ', 'i', 's', ' ', 'a', ' ', 's', 'e', 'n', 't', 'e', 'n', 'c', 'e'],\n *      index: 18,\n *    }\n * \n * @param parser The parser not to match\n * @returns A parser that matches any character except the ones matched by the given parser\n */\nexport const anyCharExcept = <T>(parser: Parser<T>): Parser<string> =>\n  new Parser(function anyCharExcept$state(state) {\n    if (state.isError) return state\n    const { dataView, index } = state\n\n    const out = parser.p(state)\n    if (out.isError) {\n      if (index < dataView.byteLength) {\n        const charWidth = getNextCharWidth(index, dataView)\n        if (index + charWidth <= dataView.byteLength) {\n          const char = getUtf8Char(index, charWidth, dataView)\n          return updateState(state, index + charWidth, char)\n        }\n      }\n      return updateError(\n        state,\n        `ParseError @ index ${index} -> anyCharExcept: Unexpected end of input`\n      )\n    }\n\n    return updateError(\n      state,\n      `ParseError @ index ${index} -> anyCharExcept: Matched '${out.result}' from the exception parser`\n    )\n  })\n",
    "import {\n  Parser,\n  updateError,\n  updateResult,\n  updateState,\n} from '../../parser/parser'\n\n/**\n * `everythingUntil` is a higher-order parser that collects and returns all the values from the input\n * until it encounters an error when running the provided parser.\n *\n * @example\n * const parser = everythingUntil(str(\"end\"));\n * parser.run(\"123end456\");  // returns [49, 50, 51] (ASCII codes for \"1\", \"2\", \"3\")\n * parser.run(\"123456\");  // return `ParseError @ index 6 -> everythingUntil: Unexpected end of input`\n *\n * @template T - The generic parameter representing the type of value the provided parser produces.\n *\n * @param {Parser<T>} parser - The parser that when fails, signals `everythingUntil` to stop collecting values.\n *\n * @returns {Parser<number[], string>} A new parser that will collect and return all parsed values\n * until the provided parser fails.\n */\nexport const everythingUntil = <T>(parser: Parser<T>): Parser<number[]> =>\n  new Parser((state) => {\n    if (state.isError) return state\n\n    const results: number[] = []\n    let nextState = state\n\n    while (true) {\n      const out = parser.p(nextState)\n\n      if (out.isError) {\n        const { index, dataView } = nextState\n\n        if (dataView.byteLength <= index) {\n          return updateError(\n            nextState,\n            `ParseError @ index ${index} -> everythingUntil: Unexpected end of input`\n          )\n        }\n\n        const val = dataView.getUint8(index)\n        if (val) {\n          results.push(val)\n          nextState = updateState(nextState, index + 1, val)\n        }\n      } else {\n        break\n      }\n    }\n\n    return updateResult(nextState, results)\n  })\n",
    "import { Parser } from '../../parser'\nimport { decoder } from '../../util'\nimport { everythingUntil } from '../everything-until'\n\n/**\n * `everyCharUntil` is a higher order parser that parses an input stream until a specific condition, defined by another parser, is met.\n * Unlike `everythingUntil`, this parser converts the collected bytes to a string using a `TextDecoder`.\n *\n * @example\n * const parser = everyCharUntil(str(\"end\"));\n * parser.run(\"123end456\");  // returns \"123\"\n * parser.run(\"Hello World\");  // returns \"Hello World\", as \"end\" is not found\n *\n * @param {Parser<T>} parser - A parser that defines the condition for the end of parsing.\n *\n * @returns {Parser<string>} A parser that consumes the input until the parser parameter returns a successful state.\n */\nexport const everyCharUntil = <T>(parser: Parser<T>) =>\n  everythingUntil(parser).map((results) =>\n    decoder.decode(Uint8Array.from(results))\n  )\n",
    "import { Parser, ParserState, updateError } from '../../parser'\n\n/**\n * `choice` is a parser combinator that tries each parser in a given list of parsers, in order,\n * until one succeeds. If a parser succeeds, it consumes the relevant input and returns the result.\n * If no parser succeeds, `choice` fails with an error message.\n * An error is also thrown if `choice` is called without a list or with an empty list.\n *\n * @example\n * const parser = choice([str(\"abc\"), str(\"123\")])\n * parser.run(\"abc123\")  // returns \"abc\"\n * parser.run(\"123abc\")  // returns \"123\"\n * parser.run(\"xyz\")  // returns \"ParseError @ index 0 -> choice: Unable to match with any parser\"\n * choice([])  // throws `choice requires a non-empty list of parsers`\n *\n * @param parsers The list of parsers to try in order.\n * @throws {Error} If `parsers` is an empty list.\n * @returns {Parser<any>} A parser that applies the first successful parser in `parsers`.\n */\nexport function choice<T, E = string>(parsers: Parser<T, E>[]): Parser<T, E>\nexport function choice<T extends readonly Parser<any, any>[]>(parsers: T): Parser<T[number] extends Parser<infer R, any> ? R : never, T[number] extends Parser<any, infer Err> ? Err : never>\nexport function choice<T extends Parser<any, any>[]>(\n  parsers: T\n) {\n  if (parsers.length === 0) {\n    throw new Error('choice requires a non-empty list of parsers');\n  }\n\n  if (parsers.length === 1) {\n    return parsers[0] as Parser<T[number] extends Parser<infer U> ? U : never>\n  }\n\n  return new Parser((state) => {\n    if (state.isError) return state;\n\n    for (const p of parsers) {\n      const out = p.p(state);\n      if (!out.isError) return out as ParserState<T[number] extends Parser<infer U> ? U : never, string>;\n    }\n\n    return updateError(\n      state,\n      `ParseError @ index ${state.index} -> choice: Unable to match with any parser`\n    );\n  });\n}\n",
    "import { Parser, ParserState, updateResult } from '../../parser/parser'\n\n/**\n * A function that represents the shape of a parser function.\n * @template T The type of the parser result.\n */\ntype ParserFn<T> = (_yield: <K>(parser: Parser<K>) => K) => T\n\n/**\n * `coroutine` is a parser that allows for advanced control flow and composition of parsers.\n *\n * @example\n * const parserFn: ParserFn<number> = (yield) => {\n *   const x = yield(parserA);\n *   const y = yield(parserB);\n *   return x + y;\n * };\n *\n * const coroutineParser = coroutine(parserFn);\n * coroutineParser.run(input);\n *\n * @template T The type of the parser result.\n * @param {ParserFn<T>} parserFn The parser function that defines the coroutine logic.\n * @returns {Parser<T>} A coroutine parser.\n */\nexport const coroutine = <T>(parserFn: ParserFn<T>): Parser<T> => {\n  return new Parser((state) => {\n    let currentValue\n    let currentState = state\n\n    const run = <T>(parser: Parser<T>) => {\n      if (!(parser && parser instanceof Parser)) {\n        throw new Error(\n          `coroutine passed values must be parsers, got ${parser}`\n        )\n      }\n\n      const newState = parser.p(currentState)\n      if (newState.isError) {\n        throw newState\n      } else {\n        currentState = newState\n      }\n\n      currentValue = currentState.result\n      return currentValue\n    }\n\n    try {\n      const result = parserFn(run)\n      return updateResult(currentState, result)\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e\n      } else {\n        return e as ParserState<any, any>\n      }\n    }\n  })\n}\n",
    "import { Parser, updateError, updateState } from '../../parser'\nimport { getNextCharWidth, getUtf8Char } from '../../util'\n\nconst digitRegex = /^[0-9]/\n\n/**\n * `digit` reads a single digit from the input.\n * It matches any numeric digit character from 0 to 9.\n *\n * @example\n * const parser = digit;\n * parser.run('1'); // returns { isError: false, result: '1', index: 1 }\n * parser.run('a'); // returns { isError: true, error: \"ParseError @ index 0 -> digit: Expected digit, got 'a'\", index: 0 }\n *\n * @returns {Parser<string>} A parser that reads a single digit from the input.\n */\nexport const digit: Parser<string> = new Parser((state) => {\n  if (state.isError) return state\n\n  const { dataView, index } = state\n\n  if (dataView.byteLength > index) {\n    const charWidth = getNextCharWidth(index, dataView)\n\n    if (index + charWidth <= dataView.byteLength) {\n      const char = getUtf8Char(index, charWidth, dataView)\n\n      return dataView.byteLength && char && digitRegex.test(char)\n        ? updateState(state, index + charWidth, char)\n        : updateError(\n            state,\n            `ParseError @ index ${index} -> digit: Expected digit, but got '${char}'`\n          )\n    }\n  }\n\n  return updateError(\n    state,\n    `ParseError @ index ${index} -> digit: Expected digit, but got end of input.`\n  )\n})\n",
    "import { Parser, ParserState, updateError, updateState } from '../../parser'\nimport { encoder, getString } from '../../util'\n\n/**\n * `regex` is a parser that tries to match a given Regular Expression `re` against its input.\n * If the input starts with a string that matches `re`, it consumes the matched characters and\n * returns an `Ok` result with the match as a string and the next position in the input.\n * If there's no match, it returns an `Err` result with an error message and the current position.\n * An error is also thrown if `regex` is not called with a Regular Expression or if the Regular\n * Expression doesn't start with the '^' assertion.\n *\n * @example\n * const parser = regex(/^[a-z]+/)\n * parser.run(\"abcd123\")  // returns { isError: false, result: \"abcd\", index: 4 }\n * parser.run(\"123abcd\")  // returns { isError: true, error: \"ParseError @ index 0 -> regex: Tried to match '/^[a-z]+/', got '123ab...'\", index: 0 }\n * regex(\"abcd\")  // throws `regex must be called with a Regular Expression, but got [object String]`\n * regex(/abc/)  // throws `regex parsers must contain '^' start assertion`\n *\n * @param re The Regular Expression to match against the input.\n * @throws {TypeError} If `re` is not a Regular Expression.\n * @throws {Error} If `re` doesn't start with the '^' assertion.\n * @return {Parser<string>} A parser that tries to match the input against `re`.\n */\nexport const regex = (re: RegExp): Parser<string> => {\n  const typeofre = Object.prototype.toString.call(re)\n  if (typeofre !== '[object RegExp]') {\n    throw new TypeError(\n      `regex must be called with a Regular Expression, but got ${typeofre}`\n    )\n  }\n\n  if (re.toString()[1] !== '^') {\n    throw new Error(`regex parsers must contain '^' start assertion`)\n  }\n\n  return new Parser<string>((state): ParserState<string, string> => {\n    if (state.isError) return state\n    const { dataView, index } = state\n    const rest = getString(index, dataView.byteLength - index, dataView)\n\n    if (rest.length >= 1) {\n      const match = rest.match(re)\n      return match\n        ? updateState(\n            state,\n            index + encoder.encode(match[0]).byteLength,\n            match[0]\n          )\n        : updateError(\n            state,\n            `ParseError @ index ${index} -> regex: Tried to match ${re}, got '${rest.slice(\n              0,\n              5\n            )}...'`\n          )\n    }\n\n    return updateError(\n      state,\n      `ParseError @ index ${index} -> regex: Tried to match ${re}, but got unexpected end of input`\n    )\n  })\n}\n",
    "import { Parser } from '../../parser/parser'\nimport { regex } from '../regex'\n\nconst digitsRegex = /^[0-9]+/\n\n/**\n * `digits` is a parser that matches one or more digit characters at the start of its input,\n * using a regular expression. If it finds a match, it consumes the matched characters and returns them as a string.\n * If no match is found, it fails with an error message.\n *\n * @example\n * digits.run(\"123abc\")  // returns \"123\"\n * digits.run(\"abc123\")  // returns \"ParseError @ index 0 -> digits: Expected digits\"\n *\n * @returns {Parser<string>} A parser that matches one or more digit characters.\n */\nexport const digits: Parser<string> = regex(digitsRegex).errorMap(\n  ({ index }) => `ParseError @ index ${index} -> digits: Expected digits`\n)\n",
    "import { InputTypes } from '../../input-types'\nimport { Parser, updateError, updateResult } from '../../parser/'\n\n/**\n * `endOfInput` checks if the input stream has been fully consumed.\n * If the input stream has been consumed, it returns a successful parser state with a `null` result.\n * If there are still unparsed bytes in the input, it returns a failed parser state with an error message.\n *\n * @example\n * const parser = sequenceOf(str(\"abc\"), endOfInput);\n * parser.run(\"abc\");  // returns null\n * parser.run(\"abcxyz\");  // returns `ParseError @ index 3 -> endOfInput: Expected end of input, but got 'x'`\n *\n * @returns {Parser<null, string>} A parser that asserts the end of the input stream.\n */\nexport const endOfInput = new Parser<null, string>((state) => {\n  if (state.isError) return state\n  const { dataView, index, inputType } = state\n\n  if (index !== dataView.byteLength) {\n    const errorByte =\n      inputType === InputTypes.STRING\n        ? String.fromCharCode(dataView.getUint8(index))\n        : `0x${dataView.getUint8(index).toString(16).padStart(2, '0')}`\n\n    return updateError(\n      state,\n      `ParseError @ index ${index} -> endOfInput: Expected end of input, but got '${errorByte}'`\n    )\n  }\n\n  return updateResult(state, null)\n})\n",
    "import { Parser, updateResult } from \"../../parser\";\n\nconst errorExpectRegex = /ParseError @ index (\\d+) ->.+Expected/\n\n/**\n * `exactly` is a parser combinator that applies a given parser exactly `n` times.\n * It collects the results of each successful parse into an array.\n * If `n` is 1, it returns a parser that produces a single-element array.\n *\n * @example\n * const parser = P.exactly(3)(P.letter);\n * parser.run('abc'); // returns { isError: false, result: ['a', 'b', 'c'], index: 3 }\n *\n * @template T The type of result that the parser will produce.\n * @param n The number of times the parser should be applied.\n * @param parser The parser to apply `n` times.\n * @returns {Parser<T[]>} A parser that applies the given parser `n` times and collects the results in an array.\n */\nexport function exactly<T, N extends number>(n: N): (p: Parser<T>) => Parser<T[]> {\n  if (typeof n !== \"number\" || n <= 0) {\n    throw new TypeError(`exactly must be called with a number > 0, but got ${n}`);\n  }\n\n  return (parser: Parser<T>) =>\n    new Parser((state) => {\n      if (state.isError) return state;\n\n      const results: T[] = [];\n      let nextState = state;\n\n      for (let i = 0; i < n; i++) {\n        const out = parser.p(nextState);\n\n        if (out.isError) {\n          return out;\n        } else {\n          nextState = out;\n          results.push(nextState.result);\n        }\n      }\n\n      return updateResult(nextState, results);\n    }).errorMap(({ index, error }) => `ParseError @ index ${index} -> exactly: Expected ${n}${error.replace(errorExpectRegex, \"\")}`);\n}",
    "import { Parser, updateError, updateState } from '../../parser'\nimport { getNextCharWidth, getUtf8Char } from '../../util'\n\nconst letterRegex = /^[A-Za-z]/\n\n/**\n * `letter` reads a single letter from the input.\n * It matches any uppercase or lowercase letter from the English alphabet.\n *\n * @example\n * const parser = letter;\n * parser.run('a'); // returns { isError: false, result: 'a', index: 1 }\n * parser.run('1'); // returns { isError: true, error: \"ParseError @ index 0 -> letter: Expected letter, got '1'\", index: 0 }\n *\n * @returns {Parser<string>} A parser that reads a single letter from the input.\n */\nexport const letter: Parser<string> = new Parser((state) => {\n  if (state.isError) return state\n\n  const { index, dataView } = state\n\n  if (dataView.byteLength > index) {\n    const charWidth = getNextCharWidth(index, dataView)\n    if (index + charWidth <= dataView.byteLength) {\n      const char = getUtf8Char(index, charWidth, dataView)\n      return dataView.byteLength && char && letterRegex.test(char)\n        ? updateState(state, index + charWidth, char)\n        : updateError(\n            state,\n            `ParseError @ index ${index} -> letter: Expected letter, but got '${char}'`\n          )\n    }\n  }\n\n  return updateError(\n    state,\n    `ParseError @ index ${index} -> letter: Expected letter, but got end of input.`\n  )\n})\n",
    "import { Parser } from '../../parser/parser'\nimport { regex } from '../regex'\n\nconst lettersRegex = /^[A-Za-z]+/\n\n/**\n * `letters` is a parser that tries to match one or more alphabetic characters at the start of its input.\n * If the input starts with one or more letters, it consumes the matched characters and returns them.\n * If the input doesn't start with a letter, it fails with an error message indicating where the mismatch occurred.\n *\n * This parser uses a regular expression to define what it considers a \"letter\".\n * By default, it considers both uppercase and lowercase letters from any language.\n *\n * @example\n * letters.run(\"abcd1234\")  // returns \"abcd\"\n * letters.run(\"1234abcd\")  // returns \"ParseError @ index 0 -> letters: Expected letters\"\n *\n * @returns {Parser<string>} A parser that tries to match one or more alphabetic characters.\n */\nexport const letters: Parser<string> = regex(lettersRegex).errorMap(\n  ({ index }) => `ParseError @ index ${index} -> letters: Expected letters`\n)\n",
    "import { Parser, updateError, updateResult } from '../../parser/parser'\n\n/**\n * `lookAhead` runs the given parser without consuming the input.\n *\n * @example\n * const parser = sequenceOf([str(\"hello \"), lookAhead(str(\"world\")), str(\"world\")])\n * parser.run(\"hello world\")  { isError: false, result: [\"hello \", \"world\", \"world\"], index: 11 }\n *\n * @param parser\n * @returns\n */\nexport const lookAhead = <T, E>(parser: Parser<T, E>): Parser<T, E> =>\n  new Parser((state) => {\n    if (state.isError) return state\n\n    const nextState = parser.p(state)\n    return nextState.isError\n      ? updateError(state, nextState.error)\n      : updateResult(state, nextState.result)\n  })\n",
    "import { Parser, updateResult } from '../../parser'\n\n/**\n * `many` is a parser combinator that applies a given parser zero or more times.\n * It collects the results of each successful parse into an array, and stops\n * when the parser can no longer match the input.\n * It doesn't fail when the parser doesn't match the input at all; instead, it returns an empty array.\n *\n * @example\n * const parser = many(str(\"abc\"))\n * parser.run(\"abcabcabcxyz\")  // returns [\"abc\", \"abc\", \"abc\"]\n * parser.run(\"xyzabcabcabc\")  // returns []\n *\n * @template T The type of result that the parser will produce.\n *\n * @param parser The parser to apply zero or more times.\n * @returns {Parser<T[]>} A parser that applies `parser` zero or more times.\n */\nexport const many = function many<T>(parser: Parser<T>): Parser<T[]> {\n  return new Parser((state) => {\n    if (state.isError) return state\n\n    const results: Array<T> = []\n    let done = false\n    let nextState = state\n\n    while (!done) {\n      const out = parser.p(nextState)\n\n      if (!out.isError) {\n        nextState = out\n        results.push(nextState.result)\n\n        if (nextState.index >= nextState.dataView.byteLength) {\n          done = true\n        }\n      } else {\n        done = true\n      }\n    }\n\n    return updateResult(nextState, results)\n  })\n}\n",
    "import { Parser, updateError } from '../../parser'\nimport { many } from './many'\n\n/**\n * `manyOne` is similar to `many`, but it requires the input parser to match the input at least once.\n * If the input parser doesn't match the input at all, `manyOne` fails with an error.\n * Otherwise, it applies the parser as many times as possible and collects the results into an array.\n *\n * @example\n * const parser = manyOne(str(\"abc\"))\n * parser.run(\"abcabcabcxyz\")  // returns [\"abc\", \"abc\", \"abc\"]\n * parser.run(\"xyzabcabcabc\")  // returns \"ParseError @ index 0 -> manyOne: Expected to match at least one value\"\n *\n * @template T The type of result that the parser will produce.\n *\n * @param parser The parser to apply one or more times.\n * @returns {Parser<T[]>} A parser that applies `parser` one or more times.\n */\nexport const manyOne = function manyOne<T>(parser: Parser<T>): Parser<T[]> {\n  return new Parser((state) => {\n    if (state.isError) return state\n\n    const out = many(parser).p(state)\n\n    if (out.result.length) {\n      return out\n    }\n\n    return updateError(\n      state,\n      `ParseError @ index ${state.index} -> manyOne: Expected to match at least one value`\n    )\n  })\n}\n",
    "import { Parser, updateError, updateState } from '../../parser/parser'\n\n/**\n * `peek` peeks (u don't say) at the next byte in the input, without consuming it.\n * It returns the value of the next byte as a number.\n *\n * @example\n * const parser = P.peek;\n * const data = new Uint8Array([1, 2, 3]);\n * parser.run(new DataView(data.buffer)); // returns { isError: false, result: 1, index: 0 }\n *\n * @returns {Parser<number>} A parser that peeks at the next byte in the input.\n */\nexport const peek: Parser<number> = new Parser((state) => {\n  if (state.isError) return state\n\n  const { index, dataView } = state\n\n  if (index < dataView.byteLength) {\n    return updateState(state, index, dataView.getUint8(index))\n  }\n\n  return updateError(\n    state,\n    `ParseError @ index ${index} -> peek: Unexpected end of input`\n  )\n})\n",
    "import { Parser, updateResult } from '../../parser'\n\n/**\n * `possibly` is a parser combinator that applies a given parser and returns its result,\n * or `null` if the parser fails.\n *\n * @example\n * const parser = possibly(P.letters);\n * parser.run('abc'); // returns { isError: false, result: 'abc', index: 3 }\n * parser.run('123'); // returns { isError: false, result: null, index: 0 }\n *\n * @template T The type of the result produced by the parser.\n * @template E The type of the error produced by the parser.\n * @param parser The parser to apply.\n * @returns {Parser<T | null, E>} A parser that returns the result of the applied parser, or `null` if it fails.\n */\nexport const possibly = <T, E>(parser: Parser<T, E>): Parser<T | null, E> => {\n  return new Parser((state) => {\n    if (state.isError) return state\n\n    const nextState = parser.p(state)\n    return nextState.isError ? updateResult(state, null) : nextState\n  })\n}\n",
    "import { Parser } from '../../parser'\n\n/**\n * `recursive` is a parser combinator that allows creating parsers which reference themselves,\n * enabling parsing of recursive constructs. It accepts a function that returns a parser,\n * and when it is invoked, it will call the provided function and run the resulting parser.\n *\n * It's particularly useful when trying to define parsers for nested structures like JSON or HTML,\n * where the exact same structure can recursively appear within itself.\n *\n * @example\n * let arrayParser = recursive(() => sequenceOf([str(\"[\"), sepBy(str(\",\"))(valueParser), str(\"]\")]))\n * arrayParser.run(\"[1,2,[3,4],[5,[6,7]]]\")  // returns the nested array structure\n *\n * @template T The type of result that the parser will produce.\n * @template E The type of error that the parser can return.\n *\n * @param parserThunk A function that returns a parser. This is to avoid immediate execution of the parser.\n * @returns {Parser<T, E>} A parser that can parse recursive structures.\n */\nexport const recursive = <T, E = string>(\n  parserThunk: () => Parser<T, E>\n): Parser<T, E> =>\n  new Parser((state) => {\n    return parserThunk().p(state)\n  })\n",
    "import { Parser, ParserState, updateResult } from '../../parser'\n\n/**\n * `sepBy` is a parser that matches zero or more occurrences of a value, separated by a given separator.\n * It returns an array of values that were separated by the separator.\n * If the separator does not occur in the input, the parser returns an empty array.\n *\n * @template S Type of the separator\n * @template V Type of the value\n * @template E Type of the potential error produced by the parsers\n *\n * @param {Parser<S, E>} sepParser The parser for the separator\n * @returns {(valueParser: Parser<V, E>) => Parser<V[], E>} Function taking a value parser and returning a new parser\n *\n * @example\n * const commaSeparatedNumbers = sepBy(char(','))(manyOne(digits));\n * const result = commaSeparatedNumbers.run(\"1,2,3,4\");\n * // result is { isError: false, result: ['1','2','3','4'], ... }\n */\nexport const sepBy =\n  <S, V, E>(sepParser: Parser<S, E>) =>\n  (valueParser: Parser<V, E>): Parser<Array<V>> =>\n    new Parser<Array<V>>((state) => {\n      if (state.isError) return state\n\n      const results: Array<V> = []\n      let nextState: ParserState<S | V, E> = state\n\n      while (true) {\n        const valueState = valueParser.p(nextState)\n\n        if (valueState.isError) {\n          break\n        }\n\n        results.push(valueState.result)\n        nextState = valueState\n\n        const sepState = sepParser.p(valueState)\n        if (sepState.isError) {\n          break\n        }\n\n        nextState = sepState\n      }\n\n      return updateResult(nextState, results)\n    })\n",
    "import { Parser, updateError } from '../../parser'\nimport { sepBy } from './sep-by'\n\n/**\n * `sepByOne` is a parser combinator that accepts two parsers as arguments: `sepParser` and `valueParser`.\n * It applies the `valueParser` and `sepParser` in sequence and repeats this process until `valueParser` fails.\n * If at least one value is matched, it returns an `Ok` result with an array of matched values.\n * If no values are matched, it fails and returns an `Err` with an error message indicating that it expected to match at least one separated value.\n *\n * @example\n * const parser = sepByOne(str(\", \"))(letters)\n * parser.run(\"a, b, c\")  // returns { isError: false, result: [\"a\", \"b\", \"c\"], index: 8 }\n * parser.run(\"123\")  // returns { isError: true, error: \"ParseError @ index 0 -> sepByOne: Expected to match at least one separated value\", index: 0 }\n *\n * @param sepParser The parser that recognizes the separator.\n * @param valueParser The parser that recognizes the values to be separated.\n * @returns {Parser<Array<V>>} A parser that applies `sepParser` and `valueParser` in sequence until `valueParser` fails and returns an array of matched values.\n */\nexport const sepByOne =\n  <S, V, E>(sepParser: Parser<S, E>) =>\n  (valueParser: Parser<V, E>): Parser<Array<V>> =>\n    new Parser((state) => {\n      if (state.isError) return state\n\n      const out = sepBy(sepParser)(valueParser).p(state)\n\n      if (out.result.length === 0) {\n        return updateError(\n          state,\n          `ParseError @ index ${state.index} -> sepByOne: Expected to match at least one separated value`\n        )\n      }\n\n      return out\n    })\n",
    "import { Parser, updateError } from '../../parser'\n\n/**\n * `startOfInput` is a parser that expects the parser to be at the start of the input.\n * If the parser is not at the start of the input, it fails with a `ParseError`.\n *\n * @example\n * const parser = sequenceOf(startOfInput, str(\"abc\"))\n * parser.run(\"abc\")  { isError: false, result: [null, \"abc\"], index: 3 }\n * parser.run(\"xyzabc\")  { isError: true, index: 0,  error: `ParseError @ index 0 -> startOfInput: Expected start of input` }\n *\n * @returns {Parser<null, string>} A parser that expects the start of input.\n */\nexport const startOfInput = new Parser<null, string>((state) => {\n  if (state.isError) return state\n  const { index } = state\n  if (index > 0) {\n    return updateError(\n      state,\n      `ParseError @ index ${index} -> startOfInput: Expected start of input`\n    )\n  }\n\n  return state\n})\n",
    "import {\n  Parser,\n  ParserState,\n  updateError,\n  updateState,\n} from '../../parser/parser'\nimport { encoder, getCharacterLength, getString } from '../../util'\n\n/**\n * `str` is a parser that tries to match a given input string `s` against its input.\n * If the input starts with `s`, it returns an `Ok` result with `s` as the result and the next position in the input.\n * Otherwise, it fails and returns an `Err` with an error message indicating where the mismatch occurred.\n * An error is also thrown if `str` is called without a string or with an empty string.\n *\n * @example\n * const parser = str(\"abcd\")\n * parser.run(\"abcd1234\")  // returns { isError: false, result: \"abcd\", index: 4 }\n * parser.run(\"1234abcd\")  // returns { isError: true, error: \"ParseError @ index 0 -> str: Tried to match 'abcd', but got '1234...'\", index: 0 }\n * str(\"\")  // throws `str must be called with a string with length > 1, but got ''`\n *\n * @param s The string to match against the input.\n * @throws {TypeError} If `s` is not a string or is an empty string.\n * @return {Parser<string>} A parser that tries to match the input against `s`.\n */\nexport const str = (s: string): Parser<string> => {\n  if (!s || getCharacterLength(s) < 1) {\n    throw new TypeError(\n      `str must be called with a string with length > 1, but got '${s}'`\n    )\n  }\n\n  const encodedStr = encoder.encode(s)\n\n  return new Parser((state): ParserState<string, string> => {\n    const { dataView, index, isError } = state\n\n    if (isError) return state\n\n    const remainingBytes = dataView.byteLength - index\n\n    if (remainingBytes < encodedStr.byteLength) {\n      return updateError(\n        state,\n        `ParseError @ index ${index} -> str: Tried to match '${s}', but got unexpected end of input`\n      )\n    }\n\n    const stringAtIndex = getString(index, encodedStr.byteLength, dataView)\n    if (s === stringAtIndex) {\n      return updateState(state, index + s.length, s)\n    }\n\n    return updateError(\n      state,\n      `ParseError @ index ${index} -> str: Tried to match '${s}', but got '${stringAtIndex}...'`\n    )\n  })\n}\n",
    "import { Parser } from '../../parser'\nimport { regex } from '../regex'\n\nconst wsRegex = /^\\s+/\n\n/**\n * `whitespace` matches any whitespace character.\n *\n * @example\n * const parser = P.whitespace;\n * parser.run('  \\t\\n'); // returns { isError: false, result: '  \\t\\n', index: 4 }\n * parser.run('abc'); // returns { isError: true, error: \"ParseError @ index 0 -> regex: Expected regex match\", index: 0 }\n *\n * @returns {Parser<string>} A parser that matches any whitespace character.\n */\nexport const whitespace: Parser<string> = regex(wsRegex)\n",
    "import { Parser } from '../../parser'\nimport { possibly } from '../possibly'\nimport { whitespace } from './whitespace'\n\n/**\n * `optionalWhitespace` matches optional whitespace.\n * It can return either a string containing whitespace or `null` if no whitespace is found.\n *\n * @example\n * const parser = P.optionalWhitespace;\n * parser.run('  \\t\\n'); // returns { isError: false, result: '  \\t\\n', index: 4 }\n * parser.run('abc'); // returns { isError: false, result: null, index: 0 }\n *\n * @returns {Parser<string | null>} A parser that matches optional whitespace.\n */\nexport const optionalWhitespace: Parser<string | null> = possibly(\n  whitespace\n).map((x) => x || '')\n",
    "import { InputType, InputTypes } from './input-types'\nimport {\n  Err,\n  Ok,\n  Parser,\n  ParserState,\n  ResultType,\n  updateError,\n  updateResult,\n  updateState,\n  isOk,\n  isError,\n} from './parser'\nexport * from './parsers'\nimport * as Parsers from './parsers'\nimport {\n  decoder,\n  encoder,\n  getCharacterLength,\n  getNextCharWidth,\n  getString,\n  getUtf8Char,\n} from './util'\n\nexport type { ParserState, ResultType, Err, Ok, InputType }\n\nexport {\n  encoder,\n  decoder,\n  Parser,\n  isOk,\n  isError,\n  updateError,\n  updateState,\n  updateResult,\n  InputTypes,\n  getCharacterLength,\n  getNextCharWidth,\n  getString,\n  getUtf8Char,\n}\n\nexport default {\n  encoder,\n  decoder,\n  Parser,\n  isOk,\n  isError,\n  updateError,\n  updateState,\n  updateResult,\n  InputTypes,\n  getCharacterLength,\n  getNextCharWidth,\n  getString,\n  getUtf8Char,\n  ...Parsers,\n}\n"
  ],
  "mappings": "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",
  "debugId": "5D366BF6CFE9127564756E2164756E21",
  "names": []
}