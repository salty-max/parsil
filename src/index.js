var g=Object.defineProperty;var x=(_,D)=>{for(var Y in D)g(_,Y,{get:D[Y],enumerable:!0,configurable:!0,set:(G)=>D[Y]=()=>G})};var E=(_)=>_ instanceof Uint8Array||_ instanceof Uint8ClampedArray||_ instanceof Int8Array||_ instanceof Uint16Array||_ instanceof Int16Array||_ instanceof Uint32Array||_ instanceof Int32Array||_ instanceof Float32Array||_ instanceof Float64Array,z;((K)=>{K.STRING="string";K.ARRAY_BUFFER="arrayBuffer";K.TYPED_ARRAY="typedArray";K.DATA_VIEW="dataView"})(z||={});var{TextEncoder:P,TextDecoder:y}=globalThis;if(!P||!y)throw new Error("Parsil requires global TextEncoder and TextDecoder");var U=new P,k=new y,R=(_,D,Y)=>{let G=new Uint8Array(D);for(let K=0;K<D;K++)G[K]=Y.getUint8(_+K);return k.decode(G)},L=(_,D)=>{let Y=D.getUint8(_);if((Y&128)===0)return 1;if((Y&224)===192)return 2;if((Y&240)===224)return 3;if((Y&248)===240)return 4;return 1},M=(_,D,Y)=>{let G=new Uint8Array(D);for(let K=0;K<D;K++)G[K]=Y.getUint8(_+K);return k.decode(G)},C=(_)=>{let D=0;for(let Y of _)D++;return D};function b(_){return!_.isError}function f(_){return _.isError}var w=(_)=>{let D,Y;if(typeof _==="string"){let G=U.encode(_);D=new DataView(G.buffer),Y="string"}else if(_ instanceof ArrayBuffer)D=new DataView(_),Y="arrayBuffer";else if(E(_))D=new DataView(_.buffer),Y="typedArray";else if(_ instanceof DataView)D=_,Y="dataView";else throw new Error(`Cannot process input. Must be a string, ArrayBuffer, TypedArray, or DataView. Got ${typeof _}`);return{dataView:D,inputType:Y,isError:!1,error:null,result:null,index:0}};class Q{p;constructor(_){this.p=_}run(_){let D=w(_),Y=this.p(D);if(Y.isError)return{isError:!0,error:Y.error,index:Y.index};return{isError:!1,result:Y.result,index:Y.index}}fork(_,D,Y){let G=w(_),K=this.p(G);if(K.isError)return D(K.error,K);return Y(K.result,K)}map(_){return new Q((D)=>{let Y=this.p(D);if(Y.isError)return Y;return J(Y,_(Y.result))})}chain(_){return new Q((D)=>{let Y=this.p(D);if(Y.isError)return Y;return _(Y.result).p(Y)})}errorMap(_){return new Q((D)=>{let Y=this.p(D);if(!Y.isError)return Y;return Z(Y,_({isError:!0,error:Y.error,index:Y.index}))})}}var $=(_,D,Y)=>({..._,index:D,result:Y}),J=(_,D)=>({..._,result:D}),Z=(_,D)=>({..._,isError:!0,error:D});var S={};x(S,{zero:()=>d,whitespace:()=>v,uint:()=>W,succeed:()=>A,str:()=>H8,startOfInput:()=>M8,sequenceOf:()=>H,sepByOne:()=>L8,sepBy:()=>T,regex:()=>B,recursive:()=>J8,rawString:()=>c,possibly:()=>I,peek:()=>j8,optionalWhitespace:()=>F8,one:()=>l,manyOne:()=>$8,many:()=>V,lookAhead:()=>Z8,letters:()=>X8,letter:()=>K8,int:()=>o,fail:()=>q,exactly:()=>D8,everythingUntil:()=>O,everyCharUntil:()=>i,endOfInput:()=>_8,digits:()=>e,digit:()=>r,coroutine:()=>s,choice:()=>n,char:()=>h,bit:()=>N,between:()=>m,anyCharExcept:()=>p,anyChar:()=>u});function H(_){return new Q((D)=>{if(D.isError)return D;let Y=[],G=D;for(let K of _){let X=K.p(G);if(X.isError)return X;G=X,Y.push(X.result)}return J(G,Y)})}var m=(_,D)=>(Y)=>H([_,Y,D]).map(([G,K])=>K);var N=new Q((_)=>{if(_.isError)return _;let D=Math.floor(_.index/8);if(D>=_.dataView.byteLength)Z(_,`ParseError @ index ${_.index} -> bit: Unexpected end of input`);let Y=_.dataView.getUint8(D),G=7-_.index%8,K=(Y&1<<G)>>G;return $(_,_.index+1,K)});var d=new Q((_)=>{if(_.isError)return _;let D=N.p(_);if(D.result!==0)return Z(_,`ParseError @ index ${_.index} -> zero: Expected 0 but got 1`);return $(_,_.index+1,D.result)});var l=new Q((_)=>{if(_.isError)return _;let D=N.p(_);if(D.result!==1)return Z(_,`ParseError @ index ${_.index} -> one: Expected 1 but got 0`);return $(_,_.index+1,D.result)});var W=(_)=>{if(_<1)throw new Error(`uint: n must be larger than 0, but got ${_}`);if(_>32)throw new Error(`uint: n must be less than 32, but got ${_}`);return H(Array.from({length:_},()=>N)).map((D)=>{return D.reduce((Y,G,K)=>{return Y+Number(BigInt(G)<<BigInt(_-1-K))},0)})};var o=(_)=>{if(_<1)throw new Error(`int: n must be larger than 0, but got ${_}`);if(_>32)throw new Error(`int: n must be less than 32, but got ${_}`);return H(Array.from({length:_},()=>N)).map((D)=>{if(D[0]===0)return D.reduce((Y,G,K)=>{return Y+Number(BigInt(G)<<BigInt(_-1-K))},0);else return-(1+D.reduce((Y,G,K)=>{return Y+Number(BigInt(G===0?1:0)<<BigInt(_-1-K))},0))})};function q(_){return new Q((D)=>{if(D.isError)return D;return Z(D,_)})}function A(_){return new Q((D)=>{return J(D,_)})}var c=(_)=>{if(_.length<1)throw new Error("rawString: input must be at least 1 character");let D=_.split("").map((Y)=>Y.charCodeAt(0)).map((Y)=>{return W(8).chain((G)=>{if(G==Y)return A(Y);else return q(`ParseError -> rawString: Expected character ${String.fromCharCode(Y)}, but got ${String.fromCharCode(G)}`)})});return H(D)};var h=(_)=>{if(!_||C(_)!==1)throw new TypeError(`char must be called with a single character, but got '${_}'`);return new Q((D)=>{if(D.isError)return D;let{index:Y,dataView:G}=D;if(Y<G.byteLength){let K=L(Y,G);if(Y+K<=G.byteLength){let X=M(Y,K,G);if(X===_)return $(D,Y+K,_);return Z(D,`ParseError @ index 0 -> char: Expected '${_}', but got '${X}'`)}}return Z(D,`ParseError @ index 0 -> char: Expected '${_}', but got unexpected end of input`)})};var u=new Q((_)=>{if(_.isError)return _;let{index:D,dataView:Y}=_;if(D<Y.byteLength){let G=L(D,Y);if(D+G<=Y.byteLength){let K=M(D,G,Y);return $(_,D+G,K)}}return Z(_,`ParseError @ index ${D} -> anyChar: Expected a character, but got unexpected end of input`)});var p=(_)=>new Q(function D(Y){if(Y.isError)return Y;let{dataView:G,index:K}=Y,X=_.p(Y);if(X.isError){if(K<G.byteLength){let j=L(K,G);if(K+j<=G.byteLength){let F=M(K,j,G);return $(Y,K+j,F)}}return Z(Y,`ParseError @ index ${K} -> anyCharExcept: Unexpected end of input`)}return Z(Y,`ParseError @ index ${K} -> anyCharExcept: Matched '${X.result}' from the exception parser`)});var O=(_)=>new Q((D)=>{if(D.isError)return D;let Y=[],G=D;while(!0)if(_.p(G).isError){let{index:X,dataView:j}=G;if(j.byteLength<=X)return Z(G,`ParseError @ index ${X} -> everythingUntil: Unexpected end of input`);let F=j.getUint8(X);if(F)Y.push(F),G=$(G,X+1,F)}else break;return J(G,Y)});var i=(_)=>O(_).map((D)=>k.decode(Uint8Array.from(D)));function n(_){if(_.length===0)throw new Error("choice requires a non-empty list of parsers");if(_.length===1)return _[0];return new Q((D)=>{if(D.isError)return D;for(let Y of _){let G=Y.p(D);if(!G.isError)return G}return Z(D,`ParseError @ index ${D.index} -> choice: Unable to match with any parser`)})}var s=(_)=>{return new Q((D)=>{let Y,G=D,K=(X)=>{if(!(X&&X instanceof Q))throw new Error(`coroutine passed values must be parsers, got ${X}`);let j=X.p(G);if(j.isError)throw j;else G=j;return Y=G.result,Y};try{let X=_(K);return J(G,X)}catch(X){if(X instanceof Error)throw X;else return X}})};var a=/^[0-9]/,r=new Q((_)=>{if(_.isError)return _;let{dataView:D,index:Y}=_;if(D.byteLength>Y){let G=L(Y,D);if(Y+G<=D.byteLength){let K=M(Y,G,D);return D.byteLength&&K&&a.test(K)?$(_,Y+G,K):Z(_,`ParseError @ index ${Y} -> digit: Expected digit, but got '${K}'`)}}return Z(_,`ParseError @ index ${Y} -> digit: Expected digit, but got end of input.`)});var B=(_)=>{let D=Object.prototype.toString.call(_);if(D!=="[object RegExp]")throw new TypeError(`regex must be called with a Regular Expression, but got ${D}`);if(_.toString()[1]!=="^")throw new Error("regex parsers must contain '^' start assertion");return new Q((Y)=>{if(Y.isError)return Y;let{dataView:G,index:K}=Y,X=R(K,G.byteLength-K,G);if(X.length>=1){let j=X.match(_);return j?$(Y,K+U.encode(j[0]).byteLength,j[0]):Z(Y,`ParseError @ index ${K} -> regex: Tried to match ${_}, got '${X.slice(0,5)}...'`)}return Z(Y,`ParseError @ index ${K} -> regex: Tried to match ${_}, but got unexpected end of input`)})};var t=/^[0-9]+/,e=B(t).errorMap(({index:_})=>`ParseError @ index ${_} -> digits: Expected digits`);var _8=new Q((_)=>{if(_.isError)return _;let{dataView:D,index:Y,inputType:G}=_;if(Y!==D.byteLength){let K=G==="string"?String.fromCharCode(D.getUint8(Y)):`0x${D.getUint8(Y).toString(16).padStart(2,"0")}`;return Z(_,`ParseError @ index ${Y} -> endOfInput: Expected end of input, but got '${K}'`)}return J(_,null)});var Y8=/ParseError @ index (\d+) ->.+Expected/;function D8(_){if(typeof _!=="number"||_<=0)throw new TypeError(`exactly must be called with a number > 0, but got ${_}`);return(D)=>new Q((Y)=>{if(Y.isError)return Y;let G=[],K=Y;for(let X=0;X<_;X++){let j=D.p(K);if(j.isError)return j;else K=j,G.push(K.result)}return J(K,G)}).errorMap(({index:Y,error:G})=>`ParseError @ index ${Y} -> exactly: Expected ${_}${G.replace(Y8,"")}`)}var G8=/^[A-Za-z]/,K8=new Q((_)=>{if(_.isError)return _;let{index:D,dataView:Y}=_;if(Y.byteLength>D){let G=L(D,Y);if(D+G<=Y.byteLength){let K=M(D,G,Y);return Y.byteLength&&K&&G8.test(K)?$(_,D+G,K):Z(_,`ParseError @ index ${D} -> letter: Expected letter, but got '${K}'`)}}return Z(_,`ParseError @ index ${D} -> letter: Expected letter, but got end of input.`)});var Q8=/^[A-Za-z]+/,X8=B(Q8).errorMap(({index:_})=>`ParseError @ index ${_} -> letters: Expected letters`);var Z8=(_)=>new Q((D)=>{if(D.isError)return D;let Y=_.p(D);return Y.isError?Z(D,Y.error):J(D,Y.result)});var V=function _(D){return new Q((Y)=>{if(Y.isError)return Y;let G=[],K=!1,X=Y;while(!K){let j=D.p(X);if(!j.isError){if(X=j,G.push(X.result),X.index>=X.dataView.byteLength)K=!0}else K=!0}return J(X,G)})};var $8=function _(D){return new Q((Y)=>{if(Y.isError)return Y;let G=V(D).p(Y);if(G.result.length)return G;return Z(Y,`ParseError @ index ${Y.index} -> manyOne: Expected to match at least one value`)})};var j8=new Q((_)=>{if(_.isError)return _;let{index:D,dataView:Y}=_;if(D<Y.byteLength)return $(_,D,Y.getUint8(D));return Z(_,`ParseError @ index ${D} -> peek: Unexpected end of input`)});var I=(_)=>{return new Q((D)=>{if(D.isError)return D;let Y=_.p(D);return Y.isError?J(D,null):Y})};var J8=(_)=>new Q((D)=>{return _().p(D)});var T=(_)=>(D)=>new Q((Y)=>{if(Y.isError)return Y;let G=[],K=Y;while(!0){let X=D.p(K);if(X.isError)break;G.push(X.result),K=X;let j=_.p(X);if(j.isError)break;K=j}return J(K,G)});var L8=(_)=>(D)=>new Q((Y)=>{if(Y.isError)return Y;let G=T(_)(D).p(Y);if(G.result.length===0)return Z(Y,`ParseError @ index ${Y.index} -> sepByOne: Expected to match at least one separated value`);return G});var M8=new Q((_)=>{if(_.isError)return _;let{index:D}=_;if(D>0)return Z(_,`ParseError @ index ${D} -> startOfInput: Expected start of input`);return _});var H8=(_)=>{if(!_||C(_)<1)throw new TypeError(`str must be called with a string with length > 1, but got '${_}'`);let D=U.encode(_);return new Q((Y)=>{let{dataView:G,index:K,isError:X}=Y;if(X)return Y;if(G.byteLength-K<D.byteLength)return Z(Y,`ParseError @ index ${K} -> str: Tried to match '${_}', but got unexpected end of input`);let F=R(K,D.byteLength,G);if(_===F)return $(Y,K+_.length,_);return Z(Y,`ParseError @ index ${K} -> str: Tried to match '${_}', but got '${F}...'`)})};var N8=/^\s+/,v=B(N8);var F8=I(v).map((_)=>_||"");var cY={encoder:U,decoder:k,Parser:Q,isOk:b,isError:f,updateError:Z,updateState:$,updateResult:J,InputTypes:z,getCharacterLength:C,getNextCharWidth:L,getString:R,getUtf8Char:M,...S};export{d as zero,v as whitespace,$ as updateState,J as updateResult,Z as updateError,W as uint,A as succeed,H8 as str,M8 as startOfInput,H as sequenceOf,L8 as sepByOne,T as sepBy,B as regex,J8 as recursive,c as rawString,I as possibly,j8 as peek,F8 as optionalWhitespace,l as one,$8 as manyOne,V as many,Z8 as lookAhead,X8 as letters,K8 as letter,b as isOk,f as isError,o as int,M as getUtf8Char,R as getString,L as getNextCharWidth,C as getCharacterLength,q as fail,D8 as exactly,O as everythingUntil,i as everyCharUntil,_8 as endOfInput,U as encoder,e as digits,r as digit,cY as default,k as decoder,s as coroutine,n as choice,h as char,N as bit,m as between,p as anyCharExcept,u as anyChar,Q as Parser,z as InputTypes};

//# debugId=5D366BF6CFE9127564756E2164756E21
//# sourceMappingURL=index.js.map
