var{defineProperty:S,getOwnPropertyNames:L8,getOwnPropertyDescriptor:M8}=Object,H8=Object.prototype.hasOwnProperty;var f=new WeakMap,N8=(_)=>{var D=f.get(_),Y;if(D)return D;if(D=S({},"__esModule",{value:!0}),_&&typeof _==="object"||typeof _==="function")L8(_).map((G)=>!H8.call(D,G)&&S(D,G,{get:()=>_[G],enumerable:!(Y=M8(_,G))||Y.enumerable}));return f.set(_,D),D};var w=(_,D)=>{for(var Y in D)S(_,Y,{get:D[Y],enumerable:!0,configurable:!0,set:(G)=>D[Y]=()=>G})};var W8={};w(W8,{zero:()=>d,whitespace:()=>v,updateState:()=>$,updateResult:()=>J,updateError:()=>X,uint:()=>W,succeed:()=>A,str:()=>j8,startOfInput:()=>$8,sequenceOf:()=>H,sepByOne:()=>Z8,sepBy:()=>T,regex:()=>B,recursive:()=>X8,rawString:()=>h,possibly:()=>I,peek:()=>Q8,optionalWhitespace:()=>J8,one:()=>l,manyOne:()=>K8,many:()=>V,lookAhead:()=>G8,letters:()=>D8,letter:()=>Y8,isOk:()=>E,isError:()=>P,int:()=>c,getUtf8Char:()=>M,getString:()=>R,getNextCharWidth:()=>L,getCharacterLength:()=>C,fail:()=>q,exactly:()=>_8,everythingUntil:()=>O,everyCharUntil:()=>n,endOfInput:()=>e,encoder:()=>F,digits:()=>t,digit:()=>r,default:()=>z8,decoder:()=>k,coroutine:()=>a,choice:()=>s,char:()=>u,bit:()=>N,between:()=>o,anyCharExcept:()=>i,anyChar:()=>p,Parser:()=>Q,InputTypes:()=>z});module.exports=N8(W8);var b=(_)=>_ instanceof Uint8Array||_ instanceof Uint8ClampedArray||_ instanceof Int8Array||_ instanceof Uint16Array||_ instanceof Int16Array||_ instanceof Uint32Array||_ instanceof Int32Array||_ instanceof Float32Array||_ instanceof Float64Array,z;((K)=>{K.STRING="string";K.ARRAY_BUFFER="arrayBuffer";K.TYPED_ARRAY="typedArray";K.DATA_VIEW="dataView"})(z||={});var{TextEncoder:x,TextDecoder:m}=globalThis;if(!x||!m)throw new Error("Parsil requires global TextEncoder and TextDecoder");var F=new x,k=new m,R=(_,D,Y)=>{let G=new Uint8Array(D);for(let K=0;K<D;K++)G[K]=Y.getUint8(_+K);return k.decode(G)},L=(_,D)=>{let Y=D.getUint8(_);if((Y&128)===0)return 1;if((Y&224)===192)return 2;if((Y&240)===224)return 3;if((Y&248)===240)return 4;return 1},M=(_,D,Y)=>{let G=new Uint8Array(D);for(let K=0;K<D;K++)G[K]=Y.getUint8(_+K);return k.decode(G)},C=(_)=>{let D=0;for(let Y of _)D++;return D};function E(_){return!_.isError}function P(_){return _.isError}var g=(_)=>{let D,Y;if(typeof _==="string"){let G=F.encode(_);D=new DataView(G.buffer),Y="string"}else if(_ instanceof ArrayBuffer)D=new DataView(_),Y="arrayBuffer";else if(b(_))D=new DataView(_.buffer),Y="typedArray";else if(_ instanceof DataView)D=_,Y="dataView";else throw new Error(`Cannot process input. Must be a string, ArrayBuffer, TypedArray, or DataView. Got ${typeof _}`);return{dataView:D,inputType:Y,isError:!1,error:null,result:null,index:0}};class Q{p;constructor(_){this.p=_}run(_){let D=g(_),Y=this.p(D);if(Y.isError)return{isError:!0,error:Y.error,index:Y.index};return{isError:!1,result:Y.result,index:Y.index}}fork(_,D,Y){let G=g(_),K=this.p(G);if(K.isError)return D(K.error,K);return Y(K.result,K)}map(_){return new Q((D)=>{let Y=this.p(D);if(Y.isError)return Y;return J(Y,_(Y.result))})}chain(_){return new Q((D)=>{let Y=this.p(D);if(Y.isError)return Y;return _(Y.result).p(Y)})}errorMap(_){return new Q((D)=>{let Y=this.p(D);if(!Y.isError)return Y;return X(Y,_({isError:!0,error:Y.error,index:Y.index}))})}}var $=(_,D,Y)=>({..._,index:D,result:Y}),J=(_,D)=>({..._,result:D}),X=(_,D)=>({..._,isError:!0,error:D});var y={};w(y,{zero:()=>d,whitespace:()=>v,uint:()=>W,succeed:()=>A,str:()=>j8,startOfInput:()=>$8,sequenceOf:()=>H,sepByOne:()=>Z8,sepBy:()=>T,regex:()=>B,recursive:()=>X8,rawString:()=>h,possibly:()=>I,peek:()=>Q8,optionalWhitespace:()=>J8,one:()=>l,manyOne:()=>K8,many:()=>V,lookAhead:()=>G8,letters:()=>D8,letter:()=>Y8,int:()=>c,fail:()=>q,exactly:()=>_8,everythingUntil:()=>O,everyCharUntil:()=>n,endOfInput:()=>e,digits:()=>t,digit:()=>r,coroutine:()=>a,choice:()=>s,char:()=>u,bit:()=>N,between:()=>o,anyCharExcept:()=>i,anyChar:()=>p});function H(_){return new Q((D)=>{if(D.isError)return D;let Y=[],G=D;for(let K of _){let Z=K.p(G);if(Z.isError)return Z;G=Z,Y.push(Z.result)}return J(G,Y)})}var o=(_,D)=>(Y)=>H([_,Y,D]).map(([G,K])=>K);var N=new Q((_)=>{if(_.isError)return _;let D=Math.floor(_.index/8);if(D>=_.dataView.byteLength)X(_,`ParseError @ index ${_.index} -> bit: Unexpected end of input`);let Y=_.dataView.getUint8(D),G=7-_.index%8,K=(Y&1<<G)>>G;return $(_,_.index+1,K)});var d=new Q((_)=>{if(_.isError)return _;let D=N.p(_);if(D.result!==0)return X(_,`ParseError @ index ${_.index} -> zero: Expected 0 but got 1`);return $(_,_.index+1,D.result)});var l=new Q((_)=>{if(_.isError)return _;let D=N.p(_);if(D.result!==1)return X(_,`ParseError @ index ${_.index} -> one: Expected 1 but got 0`);return $(_,_.index+1,D.result)});var W=(_)=>{if(_<1)throw new Error(`uint: n must be larger than 0, but got ${_}`);if(_>32)throw new Error(`uint: n must be less than 32, but got ${_}`);return H(Array.from({length:_},()=>N)).map((D)=>{return D.reduce((Y,G,K)=>{return Y+Number(BigInt(G)<<BigInt(_-1-K))},0)})};var c=(_)=>{if(_<1)throw new Error(`int: n must be larger than 0, but got ${_}`);if(_>32)throw new Error(`int: n must be less than 32, but got ${_}`);return H(Array.from({length:_},()=>N)).map((D)=>{if(D[0]===0)return D.reduce((Y,G,K)=>{return Y+Number(BigInt(G)<<BigInt(_-1-K))},0);else return-(1+D.reduce((Y,G,K)=>{return Y+Number(BigInt(G===0?1:0)<<BigInt(_-1-K))},0))})};function q(_){return new Q((D)=>{if(D.isError)return D;return X(D,_)})}function A(_){return new Q((D)=>{return J(D,_)})}var h=(_)=>{if(_.length<1)throw new Error("rawString: input must be at least 1 character");let D=_.split("").map((Y)=>Y.charCodeAt(0)).map((Y)=>{return W(8).chain((G)=>{if(G==Y)return A(Y);else return q(`ParseError -> rawString: Expected character ${String.fromCharCode(Y)}, but got ${String.fromCharCode(G)}`)})});return H(D)};var u=(_)=>{if(!_||C(_)!==1)throw new TypeError(`char must be called with a single character, but got '${_}'`);return new Q((D)=>{if(D.isError)return D;let{index:Y,dataView:G}=D;if(Y<G.byteLength){let K=L(Y,G);if(Y+K<=G.byteLength){let Z=M(Y,K,G);if(Z===_)return $(D,Y+K,_);return X(D,`ParseError @ index 0 -> char: Expected '${_}', but got '${Z}'`)}}return X(D,`ParseError @ index 0 -> char: Expected '${_}', but got unexpected end of input`)})};var p=new Q((_)=>{if(_.isError)return _;let{index:D,dataView:Y}=_;if(D<Y.byteLength){let G=L(D,Y);if(D+G<=Y.byteLength){let K=M(D,G,Y);return $(_,D+G,K)}}return X(_,`ParseError @ index ${D} -> anyChar: Expected a character, but got unexpected end of input`)});var i=(_)=>new Q(function D(Y){if(Y.isError)return Y;let{dataView:G,index:K}=Y,Z=_.p(Y);if(Z.isError){if(K<G.byteLength){let j=L(K,G);if(K+j<=G.byteLength){let U=M(K,j,G);return $(Y,K+j,U)}}return X(Y,`ParseError @ index ${K} -> anyCharExcept: Unexpected end of input`)}return X(Y,`ParseError @ index ${K} -> anyCharExcept: Matched '${Z.result}' from the exception parser`)});var O=(_)=>new Q((D)=>{if(D.isError)return D;let Y=[],G=D;while(!0)if(_.p(G).isError){let{index:Z,dataView:j}=G;if(j.byteLength<=Z)return X(G,`ParseError @ index ${Z} -> everythingUntil: Unexpected end of input`);let U=j.getUint8(Z);if(U)Y.push(U),G=$(G,Z+1,U)}else break;return J(G,Y)});var n=(_)=>O(_).map((D)=>k.decode(Uint8Array.from(D)));function s(_){if(_.length===0)throw new Error("choice requires a non-empty list of parsers");if(_.length===1)return _[0];return new Q((D)=>{if(D.isError)return D;for(let Y of _){let G=Y.p(D);if(!G.isError)return G}return X(D,`ParseError @ index ${D.index} -> choice: Unable to match with any parser`)})}var a=(_)=>{return new Q((D)=>{let Y,G=D,K=(Z)=>{if(!(Z&&Z instanceof Q))throw new Error(`coroutine passed values must be parsers, got ${Z}`);let j=Z.p(G);if(j.isError)throw j;else G=j;return Y=G.result,Y};try{let Z=_(K);return J(G,Z)}catch(Z){if(Z instanceof Error)throw Z;else return Z}})};var F8=/^[0-9]/,r=new Q((_)=>{if(_.isError)return _;let{dataView:D,index:Y}=_;if(D.byteLength>Y){let G=L(Y,D);if(Y+G<=D.byteLength){let K=M(Y,G,D);return D.byteLength&&K&&F8.test(K)?$(_,Y+G,K):X(_,`ParseError @ index ${Y} -> digit: Expected digit, but got '${K}'`)}}return X(_,`ParseError @ index ${Y} -> digit: Expected digit, but got end of input.`)});var B=(_)=>{let D=Object.prototype.toString.call(_);if(D!=="[object RegExp]")throw new TypeError(`regex must be called with a Regular Expression, but got ${D}`);if(_.toString()[1]!=="^")throw new Error("regex parsers must contain '^' start assertion");return new Q((Y)=>{if(Y.isError)return Y;let{dataView:G,index:K}=Y,Z=R(K,G.byteLength-K,G);if(Z.length>=1){let j=Z.match(_);return j?$(Y,K+F.encode(j[0]).byteLength,j[0]):X(Y,`ParseError @ index ${K} -> regex: Tried to match ${_}, got '${Z.slice(0,5)}...'`)}return X(Y,`ParseError @ index ${K} -> regex: Tried to match ${_}, but got unexpected end of input`)})};var U8=/^[0-9]+/,t=B(U8).errorMap(({index:_})=>`ParseError @ index ${_} -> digits: Expected digits`);var e=new Q((_)=>{if(_.isError)return _;let{dataView:D,index:Y,inputType:G}=_;if(Y!==D.byteLength){let K=G==="string"?String.fromCharCode(D.getUint8(Y)):`0x${D.getUint8(Y).toString(16).padStart(2,"0")}`;return X(_,`ParseError @ index ${Y} -> endOfInput: Expected end of input, but got '${K}'`)}return J(_,null)});var B8=/ParseError @ index (\d+) ->.+Expected/;function _8(_){if(typeof _!=="number"||_<=0)throw new TypeError(`exactly must be called with a number > 0, but got ${_}`);return(D)=>new Q((Y)=>{if(Y.isError)return Y;let G=[],K=Y;for(let Z=0;Z<_;Z++){let j=D.p(K);if(j.isError)return j;else K=j,G.push(K.result)}return J(K,G)}).errorMap(({index:Y,error:G})=>`ParseError @ index ${Y} -> exactly: Expected ${_}${G.replace(B8,"")}`)}var k8=/^[A-Za-z]/,Y8=new Q((_)=>{if(_.isError)return _;let{index:D,dataView:Y}=_;if(Y.byteLength>D){let G=L(D,Y);if(D+G<=Y.byteLength){let K=M(D,G,Y);return Y.byteLength&&K&&k8.test(K)?$(_,D+G,K):X(_,`ParseError @ index ${D} -> letter: Expected letter, but got '${K}'`)}}return X(_,`ParseError @ index ${D} -> letter: Expected letter, but got end of input.`)});var R8=/^[A-Za-z]+/,D8=B(R8).errorMap(({index:_})=>`ParseError @ index ${_} -> letters: Expected letters`);var G8=(_)=>new Q((D)=>{if(D.isError)return D;let Y=_.p(D);return Y.isError?X(D,Y.error):J(D,Y.result)});var V=function _(D){return new Q((Y)=>{if(Y.isError)return Y;let G=[],K=!1,Z=Y;while(!K){let j=D.p(Z);if(!j.isError){if(Z=j,G.push(Z.result),Z.index>=Z.dataView.byteLength)K=!0}else K=!0}return J(Z,G)})};var K8=function _(D){return new Q((Y)=>{if(Y.isError)return Y;let G=V(D).p(Y);if(G.result.length)return G;return X(Y,`ParseError @ index ${Y.index} -> manyOne: Expected to match at least one value`)})};var Q8=new Q((_)=>{if(_.isError)return _;let{index:D,dataView:Y}=_;if(D<Y.byteLength)return $(_,D,Y.getUint8(D));return X(_,`ParseError @ index ${D} -> peek: Unexpected end of input`)});var I=(_)=>{return new Q((D)=>{if(D.isError)return D;let Y=_.p(D);return Y.isError?J(D,null):Y})};var X8=(_)=>new Q((D)=>{return _().p(D)});var T=(_)=>(D)=>new Q((Y)=>{if(Y.isError)return Y;let G=[],K=Y;while(!0){let Z=D.p(K);if(Z.isError)break;G.push(Z.result),K=Z;let j=_.p(Z);if(j.isError)break;K=j}return J(K,G)});var Z8=(_)=>(D)=>new Q((Y)=>{if(Y.isError)return Y;let G=T(_)(D).p(Y);if(G.result.length===0)return X(Y,`ParseError @ index ${Y.index} -> sepByOne: Expected to match at least one separated value`);return G});var $8=new Q((_)=>{if(_.isError)return _;let{index:D}=_;if(D>0)return X(_,`ParseError @ index ${D} -> startOfInput: Expected start of input`);return _});var j8=(_)=>{if(!_||C(_)<1)throw new TypeError(`str must be called with a string with length > 1, but got '${_}'`);let D=F.encode(_);return new Q((Y)=>{let{dataView:G,index:K,isError:Z}=Y;if(Z)return Y;if(G.byteLength-K<D.byteLength)return X(Y,`ParseError @ index ${K} -> str: Tried to match '${_}', but got unexpected end of input`);let U=R(K,D.byteLength,G);if(_===U)return $(Y,K+_.length,_);return X(Y,`ParseError @ index ${K} -> str: Tried to match '${_}', but got '${U}...'`)})};var C8=/^\s+/,v=B(C8);var J8=I(v).map((_)=>_||"");var z8={encoder:F,decoder:k,Parser:Q,isOk:E,isError:P,updateError:X,updateState:$,updateResult:J,InputTypes:z,getCharacterLength:C,getNextCharWidth:L,getString:R,getUtf8Char:M,...y};

//# debugId=077E4A1B726DBC7764756E2164756E21
//# sourceMappingURL=index.cjs.map
